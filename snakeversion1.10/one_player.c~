#include "one_player.h"
#define MAXREW 4


int auto_collide (Queue *s2, Queue *s1, coord auto_head)
{
	int x, y;
//	coord head_s2 = get_head(s2);
//	if ( ( auto_head.x == head_s2.x ) && ( auto_head.y == head_s2.y ) )
//			return 1;									// Both get penalised/Both made a mistake
	Node * temp = s2->tail;
	while (temp!=NULL)
	{
		
		if ((temp->data.x==auto_head.x) && (temp->data.y==auto_head.y))
			return 1;
		temp = temp->next;	
	}
	temp = s1->tail;
	while (temp!=NULL)
	{
		
		if ((temp->data.x==auto_head.x) && (temp->data.y==auto_head.y))
			return 1;
		temp = temp->next;	
	}
	return 0;
}	
	
int auto_dist_to_reward(coord auto_head, coord rew)
{
	int distx=0, disty=0;
	distx+=(auto_head.x>rew.x)?(auto_head.x-rew.x):(rew.x-auto_head.x);
	if (distx>WIDTH/2)
		distx = WIDTH-distx;
	disty+=(auto_head.y>rew.y)?(auto_head.y-rew.y):(rew.y-auto_head.y);
	if (disty>HEIGHT/2)
		disty = HEIGHT-disty;
	return (distx+disty);
}

int auto_check_bomb(bomb *b, bombregion *br, coord * new_head)
{
	int i;
	if ((b->isexploding==1)|| (b->isactive==1))
	{
		for (i=0; i<SIZEBOMBREGION; i++)
			if ((br->array[i].x==new_head->x) && (br->array[i].y==new_head->y))
				return 1;
	}
	return 0;
}	


int over[MAXREW];
int perm[MAXREW];



void generate_perm(coord *new_head, reward *rew, int *min_distance, int ctr)
{
	int i, j;
	if (ctr==rew->rewnum)
	{
//		ctr=0; 
		int dist = auto_dist_to_reward(*new_head, rew->rewcoord[perm[0]]);
		for (j=1; j<rew->rewnum; j++)
		{
			dist+= auto_dist_to_reward(rew->rewcoord[perm[j-1]], rew->rewcoord[perm[j]]);
	//		perm[j]=-1;
		}
		if (*min_distance>dist)
			*min_distance=dist;
		mvprintw(HEIGHT, 0, "%d,%d %d", perm[0], perm[1], dist);
			refresh();
			timeout(10000000);
			getch();
			return;
	}
	for (i=0; i<rew->rewnum; i++)
	{
		if (over[i]==0)
		{
			perm[ctr]=i;
			over[i]=1;
			generate_perm(new_head, rew, min_distance, ctr+1);
			over[i]=0;
		}
		
	}
}

int auto_move(Queue *s1, Queue *s2, char *snake1dir, reward *rew, bomb *b, bombregion *br, Points* p, int TIME)
{
	coord auto_head = get_head(s1);
	coord new_head = auto_head;
	int max_dist = 4*(WIDTH+HEIGHT);
	// 0 is up, 1 is right 2 is down 3 is left
	int points[4]={max_dist, max_dist, max_dist, max_dist};
	switch(*snake1dir)
	{
		case 'u': points[2]=(max_dist+2);
				break;
		case 'r': points[3]=(max_dist+2);
				break;
		case 'd': points[0]=(max_dist+2);
				break;
		case 'l': points[1]=(max_dist+2);
				break;
	}
	int i;
	for (i=0; i<rew->rewnum; i++)
			{
				over[i]=0;
				perm[i]=-1;
			}

	if (points[0]!=(max_dist+2))
	{
		if (new_head.y==0)
			new_head.y = HEIGHT;
		else
			new_head.y--;
			
		if (auto_collide(s2,s1, new_head)==1)
			points[0]=(max_dist+2);
		else if (auto_check_bomb(b, br, &new_head)==1)
			points[0]=(max_dist-2);
		else
		{
			generate_perm(&new_head, rew, &points[0], 0);
		
			
			refresh();
			timeout(10000000);
//			getch();
			//usleep(500000);
		}
	}
	new_head=auto_head;
	if (points[1]!=(max_dist+2))
	{
		if (new_head.x==WIDTH)
			new_head.x = 0;
		else
			new_head.x++;
		if (auto_collide(s2,s1, new_head)==1)
			points[1]=(max_dist+2);
		else if (auto_check_bomb(b, br, &new_head)==1)
			points[1]=max_dist-2;

		else
		{
			generate_perm(&new_head, rew, &points[1], 0);
		//	mvprintw(HEIGHT, 0, "%d", points[1]);
			refresh();
			timeout(10000000);
	//		getch();
			//usleep(500000);
	
			for (i=0; i<rew->rewnum; i++)
			{
				over[i]=0;
				perm[i]=-1;
			}
		}
	}	
						
	new_head=auto_head;
	if (points[2]!=(max_dist+2))
	{
		if (new_head.y==HEIGHT)
			new_head.y = 0;
		else
			new_head.y++;
		if (auto_collide(s2,s1, new_head)==1)
			points[2]=(max_dist+2);
		else if (auto_check_bomb(b, br, &new_head)==1)
			points[2]=(max_dist-2);

		else
		{
			generate_perm(&new_head, rew, &points[2], 0);
			//mvprintw(0, WIDTH, "%d", points[2]);
			refresh();
			timeout(10000000);
	//		getch();
			//usleep(500000);
	
			for (i=0; i<rew->rewnum; i++)
			{
				over[i]=0;
				perm[i]=-1;
			}
		}
	}					
	new_head=auto_head;
	if (points[3]!=(max_dist+2))
	{
		if (new_head.x==0)
			new_head.x = WIDTH;
		else
			new_head.x--;
		if (auto_collide(s2, s1, new_head)==1)
			points[3]=(max_dist+2);
		else if (auto_check_bomb(b, br, &new_head)==1)
			points[3]=max_dist-2;
		
		else
		{
			generate_perm(&new_head, rew, &points[3], 0);
		//	mvprintw(HEIGHT, WIDTH, "%d", points[3]);
			refresh();
			timeout(10000000);
		//	getch();
			//usleep(500000);
	
			for (i=0; i<rew->rewnum; i++)
			{
				over[i]=0;
				perm[i]=-1;
			}		
		}
	}	
	int min = points[0];
	int pos=0;
		mvprintw(HEIGHT+3, 0, "%d %d %d %d", points[0],points[1],points[2],points[3]);				
	refresh();
		//	getch();
			
	for (i=1; i<4; i++)
	{
		if (min>points[i])
		{
			min=points[i];
			pos=i;
		}
	}
	new_head=auto_head;
	timeout(TIME);
	switch(pos)
	{
		case 0:	if (new_head.y==0)
					new_head.y = HEIGHT;
				else
					new_head.y--;
				*snake1dir='u';
				break;
		case 1: if (new_head.x==WIDTH)
					new_head.x = 0;
				else
					new_head.x++;
				*snake1dir='r';
				break;
		case 2: if (new_head.y==HEIGHT)
					new_head.y = 0;
				else
					new_head.y++;
				*snake1dir='d';
				break;
		case 3: if (new_head.x==0)
					new_head.x = WIDTH;
				else
					new_head.x--;
				*snake1dir='l';
				break;
	}
	s1 = queue_push(s1, new_head);
	int flag=0;
		for (i=0; i<rew->rewnum; i++)
		{
			if ((rew->rewcoord[i].x==new_head.x)&&(rew->rewcoord[i].y==new_head.y))
			{
				mk_reward(s1, s2, rew, i);
				p->s1_points++;
				flag=1;
				break;
			}
		}
		if (flag==0)
			s1 = queue_pop(s1);
	usleep(TIME*1000);
	for (i=0; i<MAXREW; i++)
	{
		over[i]=0;
		perm[i]=-1;
	}
	return 0;		
	
}


int play_one(Queue *s1, Queue *s2, coord *snake2, char *snake2dir, reward *r,Points* p)
{
		int ch;
		int set_dir2=0;
		ch=getch();						
		switch (ch)
		{
				case (int) 'q': return 1;
				
				case 259: if ((*snake2dir=='r')||(*snake2dir=='l'))
							{
								if (snake2->y==0)
									snake2->y = HEIGHT;
								else
									snake2->y--;
								*snake2dir = 'u';
								set_dir2=1;
							}
							break;
				case 258 : if ((*snake2dir=='r')||(*snake2dir=='l'))
							{
								if (snake2->y==HEIGHT)
									snake2->y = 0;
								else
									snake2->y++;
								set_dir2=1;
								*snake2dir = 'd';
							}
							break;
				case 260 : if ((*snake2dir=='u')||(*snake2dir=='d'))
							{
								if (snake2->x==0)
									snake2->x = WIDTH;
								else
									snake2->x--;
								set_dir2=1;
								*snake2dir = 'l';
							}
							break;		
							
				case 261: if ((*snake2dir=='u')||(*snake2dir=='d'))
							{
								if (snake2->x==WIDTH)
									snake2->x = 0;
								else
									snake2->x++;
								set_dir2=1;
								*snake2dir = 'r';
							}
							break;
			}
		if (set_dir2==0)
		{
			switch(*snake2dir)
			{
				case 'l': if (snake2->x==0)
							snake2->x = WIDTH;
						else
							snake2->x--;
						break;
				case 'r': if (snake2->x==WIDTH)
							snake2->x = 0;
						else
							snake2->x++;
						break;
				case 'u': if (snake2->y==0)
							snake2->y = HEIGHT;
						else
							snake2->y--;
						break;
				case 'd': if (snake2->y==HEIGHT)
							snake2->y = 0;
						else
							snake2->y++;
						break;
			}
		}
		
		s2 = queue_push(s2, *snake2);
		int flag=0, i;
		for (i=0; i<r->rewnum; i++)
		{
			if ((r->rewcoord[i].x==snake2->x)&&(r->rewcoord[i].y==snake2->y))
			{
				mk_reward(s1, s2, r, i);
				p->s2_points++;
				flag=1;
				break;
			}
		}
		if (flag==0)
			s2 = queue_pop(s2);
		
	return 0;
}


